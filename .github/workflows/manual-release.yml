name: Manual Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  manual_release:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Calculate new version
      id: version
      run: |
        # Get the latest tag, or use v0.0.0 if no tags exist
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        
        # Extract version number
        VERSION=$(echo $LATEST_TAG | sed 's/v//')
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]:-0}
        MINOR=${VERSION_PARTS[1]:-0}
        PATCH=${VERSION_PARTS[2]:-0}
        
        # Increment based on input
        case "${{ github.event.inputs.version_bump }}" in
          "major")
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          "minor")
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          "patch")
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version will be: $NEW_VERSION (was $LATEST_TAG)"
        
    - name: Create release package
      run: |
        # Create base package directory structure
        mkdir -p sdd-package-base
        
        # Copy common folders to base
        echo "Packaging SDD common components..."
        
        if [ -d "memory" ]; then
          cp -r memory sdd-package-base/
          echo "âœ“ Copied memory folder ($(find memory -type f | wc -l) files)"
        else
          echo "âš ï¸ memory folder not found"
        fi
        
        if [ -d "scripts" ]; then
          cp -r scripts sdd-package-base/
          echo "âœ“ Copied scripts folder ($(find scripts -type f | wc -l) files)"
        else
          echo "âš ï¸ scripts folder not found"
        fi
        
        # Create Claude Code package
        echo "Creating Claude Code package..."
        mkdir -p sdd-claude-package
        cp -r sdd-package-base/* sdd-claude-package/
        if [ -d ".claude" ]; then
          cp -r .claude sdd-claude-package/
          echo "âœ“ Added Claude Code commands ($(find .claude -type f | wc -l) files)"
        else
          echo "âš ï¸ .claude folder not found"
        fi
        
        # Create Gemini CLI package
        echo "Creating Gemini CLI package..."
        mkdir -p sdd-gemini-package
        cp -r sdd-package-base/* sdd-gemini-package/
        if [ -d ".gemini" ]; then
          cp -r .gemini sdd-gemini-package/
          # Move GEMINI.md to root for easier access
          if [ -f "sdd-gemini-package/.gemini/GEMINI.md" ]; then
            mv sdd-gemini-package/.gemini/GEMINI.md sdd-gemini-package/GEMINI.md
            echo "âœ“ Moved GEMINI.md to root of Gemini package"
          fi
          # Remove empty .gemini folder if it only contained GEMINI.md
          if [ -d "sdd-gemini-package/.gemini" ] && [ -z "$(find sdd-gemini-package/.gemini -type f)" ]; then
            rm -rf sdd-gemini-package/.gemini
            echo "âœ“ Removed empty .gemini folder"
          fi
          echo "âœ“ Added Gemini CLI commands ($(find .gemini -type f | wc -l) files)"
        else
          echo "âš ï¸ .gemini folder not found"
        fi
        
        # Create GitHub Copilot package
        echo "Creating GitHub Copilot package..."
        mkdir -p sdd-copilot-package
        cp -r sdd-package-base/* sdd-copilot-package/
        if [ -d ".copilot" ]; then
          mkdir -p sdd-copilot-package/.github
          cp -r .copilot/* sdd-copilot-package/.github/
          echo "âœ“ Added Copilot instructions to .github ($(find .copilot -type f | wc -l) files)"
        else
          echo "âš ï¸ .copilot folder not found"
        fi
        
        # Create archive files for each package
        echo "Creating archive files..."
        tar -czf sdd-template-claude-${{ steps.version.outputs.new_version }}.tar.gz -C sdd-claude-package .
        cd sdd-claude-package && zip -r ../sdd-template-claude-${{ steps.version.outputs.new_version }}.zip . && cd ..
        
        tar -czf sdd-template-gemini-${{ steps.version.outputs.new_version }}.tar.gz -C sdd-gemini-package .
        cd sdd-gemini-package && zip -r ../sdd-template-gemini-${{ steps.version.outputs.new_version }}.zip . && cd ..
        
        tar -czf sdd-template-copilot-${{ steps.version.outputs.new_version }}.tar.gz -C sdd-copilot-package .
        cd sdd-copilot-package && zip -r ../sdd-template-copilot-${{ steps.version.outputs.new_version }}.zip . && cd ..
        
        echo ""
        echo "ðŸ“¦ Packages created:"
        echo "Claude: $(ls -lh sdd-template-claude-*.zip | awk '{print $5}')"
        echo "Gemini: $(ls -lh sdd-template-gemini-*.zip | awk '{print $5}')"
        echo "Copilot: $(ls -lh sdd-template-copilot-*.zip | awk '{print $5}')"
        
    - name: Generate detailed release notes
      run: |
        LAST_TAG=${{ steps.version.outputs.latest_tag }}
        
        # Get commit range
        if [ "$LAST_TAG" = "v0.0.0" ]; then
          COMMIT_RANGE="HEAD~10..HEAD"
          COMMITS=$(git log --oneline --pretty=format:"- %s" $COMMIT_RANGE 2>/dev/null || echo "- Initial release")
        else
          COMMIT_RANGE="$LAST_TAG..HEAD"
          COMMITS=$(git log --oneline --pretty=format:"- %s" $COMMIT_RANGE 2>/dev/null || echo "- No changes since last release")
        fi
        
        # Count files in each directory
        CLAUDE_COUNT=$(find .claude -type f 2>/dev/null | wc -l || echo "0")
        GEMINI_COUNT=$(find .gemini -type f 2>/dev/null | wc -l || echo "0")
        COPILOT_COUNT=$(find .copilot -type f 2>/dev/null | wc -l || echo "0")
        MEMORY_COUNT=$(find memory -type f 2>/dev/null | wc -l || echo "0")
        SCRIPTS_COUNT=$(find scripts -type f 2>/dev/null | wc -l || echo "0")
        
        cat > release_notes.md << EOF
        # ðŸš€ Specification-Driven Development (SDD) Template ${{ steps.version.outputs.new_version }}
        
        Complete SDD framework template for building spec-driven applications with AI assistance.
        
        ## ðŸ“¦ What's Included
        
        | Component | Files | Description |
        |-----------|--------|-------------|
        | \`.claude/\` | $CLAUDE_COUNT | Claude Code commands for SDD workflow |
        | \`.gemini/\` | $GEMINI_COUNT | Gemini CLI commands for SDD workflow |
        | \`.github/\` | $COPILOT_COUNT | GitHub Copilot instructions for SDD workflow |
        | \`memory/\` | $MEMORY_COUNT | Constitutional AI memory and development guidelines |
        | \`scripts/\` | $SCRIPTS_COUNT | Shell scripts for project automation |
        
        ## ðŸ—ï¸ Quick Start
        
        \`\`\`bash
        # Download and extract
        curl -L https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.new_version }}/sdd-template-${{ steps.version.outputs.new_version }}.tar.gz | tar -xz
        
        # Or use the specify CLI tool
        uvx --from git+https://github.com/${{ github.repository }}.git specify init my-project
        \`\`\`
        
        ## ðŸ”§ Prerequisites
        
        - Python 3.11+
        - AI coding assistant:
          * [Claude Code](https://claude.ai/code) - Use \`.claude/\` commands
          * [Gemini CLI](https://ai.google.dev/gemini-api/docs/cli) - Use \`.gemini/\` commands
          * [GitHub Copilot](https://github.com/features/copilot) - Use \`.github/\` instructions
        - Git
        - [UV](https://docs.astral.sh/uv/) package manager
        - [GitHub CLI](https://cli.github.com/) (optional)
        
        ## ðŸ“ Changes Since $LAST_TAG
        
        $COMMITS
        
        ## ðŸŽ¯ Key Features
        
        - **Spec-First Development**: Write specifications before code
        - **AI-Assisted Planning**: Generate implementation plans with Claude
        - **Automated Task Generation**: Break down features into actionable tasks
        - **Constitutional Memory**: Consistent AI behavior across sessions
        - **Template System**: Reusable project templates
        
        ---
        
        ðŸ“š **[Full Documentation](https://github.com/${{ github.repository }}/blob/main/README.md)** | 
        ðŸ› **[Report Issues](https://github.com/${{ github.repository }}/issues)** |
        ðŸ’¬ **[Discussions](https://github.com/${{ github.repository }}/discussions)**
        EOF
        
    - name: Create GitHub Release
      run: |
        gh release create ${{ steps.version.outputs.new_version }} \
          sdd-template-claude-${{ steps.version.outputs.new_version }}.tar.gz \
          sdd-template-claude-${{ steps.version.outputs.new_version }}.zip \
          sdd-template-gemini-${{ steps.version.outputs.new_version }}.tar.gz \
          sdd-template-gemini-${{ steps.version.outputs.new_version }}.zip \
          sdd-template-copilot-${{ steps.version.outputs.new_version }}.tar.gz \
          sdd-template-copilot-${{ steps.version.outputs.new_version }}.zip \
          --title "SDD Template ${{ steps.version.outputs.new_version }}" \
          --notes-file release_notes.md
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
